package day21

import (
	"fmt"
	"github.com/alanbriolat/AdventOfCode2018/elfcode"
	"github.com/alanbriolat/AdventOfCode2018/util"
	"log"
	"os"
)

/*
A translation of the elfcode behaviour into Go (excluding the "bitwise operation check").
 */
func translated(seed int) {
	a, c, d, e := seed, 0, 0, 0

	d = 0
	for {
		c = d | 65536
		d = 1505483

		// For each byte of c, from last to first (should be 3 bytes)
		// e.g. for first round, c = 65536, then 256, then 1
		for {
			// e.g. for first round, e = 0, 0, 1
			e = c & 255
			// d = (d + e) * 65899, in modulo 2^24
			d = (((d + e) & 16777215) * 65899) & 16777215

			// Ran out of bytes of c
			if c < 256 {
				break
			}
			// Otherwise, shift right by 8 bits
			c /= 256
		}

		// Or, to flatten the above out a bit:
		//d = (((d + (c & 255)) & 16777215) * 65899) & 16777215
		//d = (((d + ((c >> 8) & 255)) & 16777215) * 65899) & 16777215
		//d = (((d + ((c >> 16) & 255)) & 16777215) * 65899) & 16777215

		if d == a {
			return
		}
	}
}

/*
The elfcode effectively generates values until one matches register 0. This function generates the
same sequence of values and passes them to `cb`.
 */
func generateValues(cb func(d int) (halt bool)) {
	d := 0
	for {
		c := d | 65536
		d = 1505483
		d = (((d + (c & 255)) & 16777215) * 65899) & 16777215
		d = (((d + ((c >> 8) & 255)) & 16777215) * 65899) & 16777215
		d = (((d + ((c >> 16) & 255)) & 16777215) * 65899) & 16777215
		if cb(d) {
			break
		}
	}
}

/*
Finding the value that halts after the fewest instructions means finding the first value for
register 3 that is compared to register 0.
 */
func part1impl(logger *log.Logger, filename string) int {
	// Reverse-engineer the value
	var value int
	generateValues(func(d int) bool {
		value = d
		return true
	})
	logger.Printf("reverse engineered value: %d\n", value)

	// Verify it terminates
	reader, err := os.Open(filename)
	util.Check(err)
	program := elfcode.ParseProgram(reader, 6)
	processor := elfcode.Processor{Program: &program}
	processor.Init(elfcode.Registers{value})
	for {
		if halted := processor.Step(); halted {
			break
		}
	}
	logger.Printf("register 0 = %d, executed %d instructions\n", value, processor.InstructionCount)

	return value
}

/*
Finding the value that halts after the *most* instructions means finding the "last" value in the
sequence of values generated by the code. In this context, the "last" value is when any subsequent
value would result in halting earlier, if register 0 had been set to that value.

Given the structure of the question, it's reasonably safe to assume this is a "cycle detection"
problem. This implementation runs with this assumption and further assumes that the cycle only
contains each value once. Therefore, it terminates when a value is seen for a second time, and
assumes the previous value was the end of the cycle.
 */
func part2impl_slow(logger *log.Logger, filename string) int {
	reader, err := os.Open(filename)
	util.Check(err)
	program := elfcode.ParseProgram(reader, 6)
	processor := elfcode.Processor{Program: &program}
	processor.Init(elfcode.Registers{0})

	// Effectively implement a breakpoint at the important comparison instruction, returning the value being
	// compared against the "input" in register 0
	runToBreakpoint := func() int {
		for {
			if halted := processor.Step(); halted {
				return -1
			}
			if *processor.IP == 28 {
				return processor.State[3]
			}
		}
	}

	// Get the first value (should be the same as part 1)
	seen := make(map[int]struct{})
	prev := 0
	count := 0
	// Look for a cycle in the sequence of values, then use the last value in the cycle - any other value in
	// the sequence would terminate earlier.
	for !processor.Halted() {
		value := runToBreakpoint()
		count++
		if count % 100 == 0 {
			logger.Printf("iteration %d\n", count)
		}
		if _, ok := seen[value]; ok {
			break
		}
		prev = value
		seen[value] = struct{}{}
	}
	logger.Printf("repeat detected after %d iterations, %d instructions, last value before repeat = %d\n",
		count, processor.InstructionCount, prev)
	return prev
}

/*
This implements the same solution as above, but implemented in Go instead of elfcode.
It's about 30000x faster.
 */
func part2impl_opt(logger *log.Logger, filename string) int {
	seen := make(map[int]struct{})
	prev := 0
	count := 0
	generateValues(func(d int) bool {
		count++
		if _, ok := seen[d]; ok {
			return true
		}
		prev = d
		seen[d] = struct{}{}
		return false
	})
	logger.Printf("repeat detected after %d iterations, last value before repeat = %d\n", count, prev)
	return prev
}

func init() {
	util.RegisterSolution("day21part1", func(logger *log.Logger) string {
		return fmt.Sprint(part1impl(logger, "day21/input.txt"))
	})
	//util.RegisterSolution("day21part2slow", func(logger *log.Logger) string {
	//	return fmt.Sprint(part2impl_slow(logger, "day21/input.txt"))
	//})
	util.RegisterSolution("day21part2opt", func(logger *log.Logger) string {
		return fmt.Sprint(part2impl_opt(logger, "day21/input.txt"))
	})
}
